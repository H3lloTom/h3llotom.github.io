<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="neptune"><title>理解函数调用与'this'(翻译) · neptune</title><meta name="description" content="原文 Understanding JavaScript Function Invocation and “this”

[译文]理解函数调用与’this’这么些年来，我见过非常多的关于JavaScript函数调用的困惑。尤其是，许多人对于函数调用时this的语义一直无法搞清。
核心首先，让我们来看函"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><a href="/moon"><img src="/images/logo@2x.png" style="width:127px;"></a><h3 title="neptune">neptune</h3><div class="description"><p>web developer</p></div></div></div><ul class="social-links"><li><a href="https://github.com/H3lloTom"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>理解函数调用与'this'(翻译)</a></h3></div><div class="post-content"><hr>
<blockquote>
<p>原文 <a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a></p>
</blockquote>
<h3 id="译文-理解函数调用与’this’"><a href="#译文-理解函数调用与’this’" class="headerlink" title="[译文]理解函数调用与’this’"></a>[译文]理解函数调用与’this’</h3><p>这么些年来，我见过非常多的关于JavaScript函数调用的困惑。尤其是，许多人对于函数调用时<code>this</code>的语义一直无法搞清。</p>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p>首先，让我们来看函数调用的原始核心，其被称为<code>call</code>的函数内部的一个方法，这个<code>call</code>方法也是相当直截了当。</p>
<ol>
<li>产生一个参数列表（<code>argList</code>）</li>
<li>参数列表的第一个值就是<code>thisValue</code></li>
<li>将<code>this</code>的值赋给<code>thisValue</code>，然后使用<code>argList</code>作为参数列表调用函数</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.call(<span class="string">"Yehuda"</span>, <span class="string">"world"</span>) <span class="comment">//=&gt; Yehuda says hello world</span></span><br></pre></td></tr></table></figure>
<p>正如你所见到的，我们调用<code>hello</code>方法，并且传入<code>&#39;Yehuda&#39;</code>作为<code>this</code>的值和一个字符串<code>&#39;world&#39;</code>。这是最原始的javscript函数的调用方式，你能将任何其他的函数调用想象成这种方式的缩略形式。<br>^[在<a href="http://es5.github.io/#x15.3.4.4" target="_blank" rel="noopener">es5标准</a>中，<code>call</code>方法以另一种形式描述，更加底层与原始，但他（译注：当前所指的call方法）是在原始基础上包了薄薄的一层，如果你想要了解更多关于这方面的只是，请看这篇文章。]</p>
<h4 id="简单的函数调用"><a href="#简单的函数调用" class="headerlink" title="简单的函数调用"></a>简单的函数调用</h4><p>显然，在任何调用函数的时候使用<code>call</code>方法是非常让人烦恼的，JavaScript允许我们直接调用函数，当我们这样调用的时候，调用过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this:</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to:</span></span><br><span class="line">hello.call(<span class="built_in">window</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p>这种行为在es5的严格模式中有所改变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this:</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to:</span></span><br><span class="line">hello.call(<span class="literal">undefined</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p>这种短形式可以解释为：函数调用类似于 <strong>fn(…args)</strong> 与 <strong>fn.call(window [ES5-strict: undefined], …args)</strong>是相同的。<br>注意在立即执行函数中也是成立的：<strong>(function() {})()</strong> 与 <strong>(function() {}).call(window [ES5-strict: undefined)</strong>是相同的。<br>^[其实我这里有点误解了，es5标准中指出，undefined值是一直传给thisValue的，在非严格模式下会将全局对象window传入]</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>另一个常见的调用函数的场景是作为对象的成员（==person.hello()==），在这种场景下，调用被解释为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Brendan Eich"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this:</span></span><br><span class="line">person.hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to this:</span></span><br><span class="line">person.hello.call(person, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p>要注意的是，在这里，不论hello方法是怎么被赋予给对象的，还记得我们将hello函数单独在外面声明吗，我们可以看看会发生什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person = &#123; <span class="attr">name</span>: <span class="string">"Brendan Eich"</span> &#125;</span><br><span class="line">person.hello = hello;</span><br><span class="line"></span><br><span class="line">person.hello(<span class="string">"world"</span>) <span class="comment">// still desugars to person.hello.call(person, "world")</span></span><br><span class="line"></span><br><span class="line">hello(<span class="string">"world"</span>) <span class="comment">// "[object DOMWindow]world"</span></span><br></pre></td></tr></table></figure>
<p>函数没有单独的<code>this</code>概念，其总是在<code>caller</code>被调用时声明。</p>
<h3 id="使用Function-prototype-bind"><a href="#使用Function-prototype-bind" class="headerlink" title="使用Function.prototype.bind"></a>使用Function.prototype.bind</h3><p>因为可以很方便地使用一个引用来改变function中<code>this</code>的指针，人们曾经试图使用闭包的技巧将函数的<code>this</code>值绑定到已有的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Brendan Eich"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says hello "</span> + thing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundHello = <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123; <span class="keyword">return</span> person.hello.call(person, thing); &#125;</span><br><span class="line"></span><br><span class="line">boundHello(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<p>尽管boundHello方法依然解释为<code>boundHello.call(window, &quot;world&quot;)</code>,我们仍然能够使用<code>call</code>方法将<code>this</code>值变为我们想要的值。<br>我们将这个技巧做一下调整：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bind = <span class="function"><span class="keyword">function</span>(<span class="params">func, thisValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(thisValue, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundHello = bind(person.hello, person);</span><br><span class="line">boundHello(<span class="string">"world"</span>) <span class="comment">// "Brendan Eich says hello world"</span></span><br></pre></td></tr></table></figure>
<p>为了理解这里，你只需要了解两个信息。第一，<code>arguments</code>是一个类数组的对象代表所有的传入该方法的参数。第二，<code>apply</code>方法与<code>call</code>方法的原理十分类似，替代的是将列举出来的参数使用一个数组一次性传递进去。<br><code>bind</code>方法简单地返回一个新函数，当它被调用时，新的函数简单地调用传递进去的原始函数，并且将<code>this</code>的值做了一下替换，同样传递所有参数。<br>因为这是一个惯用语法，es5在<code>Function</code>对象上引进了一个新的<code>bind</code>方法代表了如下的行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boundHello = person.hello.bind(person);</span><br><span class="line">boundHello(<span class="string">"world"</span>) <span class="comment">// "Brendan Eich says hello world"</span></span><br></pre></td></tr></table></figure>
<p>这在当你传递一个函数作为回调函数时用处最大：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Alex Russell"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says hello world"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#some-div"</span>).click(person.hello.bind(person));</span><br><span class="line"></span><br><span class="line"><span class="comment">// when the div is clicked, "Alex Russell says hello world" is printed</span></span><br></pre></td></tr></table></figure>
<p>这当然有点笨拙，<code>TC39</code>（针对ECMAScript下一个版本的委员会）继续开发更优雅，仍然向后兼容的解决方案。</p>
<h3 id="PS：I-Cheated"><a href="#PS：I-Cheated" class="headerlink" title="PS：I Cheated"></a>PS：I Cheated</h3><p>在一些场合，我的解释与标准还是有一些出入的地方。最重要的可能就是，我把func.call称作原始的。其实，标准有一个原始的解释（通常认为<code>[[Call]]</code>）被<code>func.call</code>和<code>[obj.]func()</code>使用。<br>尽管如此，让我们看看<code>func.call</code>的定义吧</p>
<ol>
<li>如果func的IsCallable是false，抛出类型错误异常</li>
<li>让参数列表变为空列表</li>
<li>如果方法被调用的时候传入不止一个参数，那么就从左到右插入进<code>argList</code></li>
<li>执行函数的<code>[[Call]]</code>方法的，并传入<code>thisArg</code>和<code>argList</code>中剩下的参数，然后返回</li>
</ol>
<p>正如你所见的，这个定义是绑定到<code>[[Call]]</code>操作上的非常简单地JavaScript原生语言。<br>如果你看了整个函数调用的定义，前面七部操作定义了<code>thisValue</code>与<code>argList</code>，最后一步就是讲<code>thiaValue</code>与<code>argList</code>传入<code>[[Call]]</code>方法，并返回结果。<br>一旦argList与thisValue值得确定，函数调用总是能按照预期进行。<br>我在call的原始性上有些许误导，但是必要的含义是相同的，具体可参见第一篇引用的标准文章。<br>未完待尽……（作者注）</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-05-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/翻译-javascript/" title="翻译,javascript">翻译,javascript </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/05/21/translate-this/,neptune,理解函数调用与'this'(翻译),;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/05/08/高性能JS之位运算/" title="位运算">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>